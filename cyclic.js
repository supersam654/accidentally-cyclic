'use strict'

// This file lets you record all `require`s that stem from a single `require`.

const Module = require('module')
const path = require('path')

// Some things we'll restore later.
const originalLoad = Module._load
const originalExit = process.exit

/**
 * Detect if an import looks like it's from another node module.
 *
 * These tend to be in a `node_modules` folder or not end with `.js`.
 *
 * @param parentPath The full path to the file that called `require`.
 * @param modulePath the full path to the file that was found by `require`.
 * @return true if this `require` call appears to be loading an external dependency.
 */
function looksLikeThirdParty (parentPath, modulePath) {
  return !modulePath.endsWith('.js') ||
      modulePath.includes('node_modules') ||
      parentPath.includes('node_modules')
}

/**
 * Check if a path looks like it is trying to import a module or an actual file.
 *
 * @param importName the string passed to `require`.
 * @return true if the given string looks like it is trying to load a module.
 */
function isModule (importName) {
  return !importName.startsWith('.') && !path.isAbsolute(importName)
}

function hijackLoad (visitor) {
  Module._load = function (request, parent, isMain) {
    const parentFullPath = parent.filename
    const moduleFullPath = Module._resolveFilename(request, parent)
    // Visit before loading the module so the dependency order seems reasonable.
    // e.g. a.js -> b.js and b.js -> c.js
    // By visiting before requiring, the order of dependencies is as expected.
    // If the order is flipped, the dependency order would also be flipped.
    //
    // However, consider a.js -> b.js and a.js -> c.js
    // Then both versions would output the same order.
    // Therefore, visit before load always gives consistently expected outputs.
    //
    // Additionally, it allows us to construct partial dependency graphs if `process.exit` is called.
    visitor(parentFullPath, moduleFullPath, request)
    const exports = originalLoad.apply(Module, arguments)
    return exports
  }
}

/**
 * Get the directory of the the file that called a method in this file.
 *
 * @return The absolute directory of the calling file.
 */
function getCallerDirectory () {
  const originalStackTrace = Error.prepareStackTrace
  Error.prepareStackTrace = (_, stack) => stack
  const err = new Error()
  const stack = err.stack
  Error.prepareStackTrace = originalStackTrace

  let currentFile = stack.shift().getFileName()
  let callerFile
  while (stack.length > 0) {
    callerFile = stack.shift().getFileName()
    // When the filename changes, we've made it to the file that called this.
    if (currentFile !== callerFile) {
      break
    }
  }

  return path.dirname(callerFile)
}

/**
 * Take a list of dependencies and make them more human-readable.
 *
 * @param originalRequest The original string passed in to `cyclic.require`.
 * @param dependencies A list of all dependencies that were generated by the original `cyclic.require`.
 * @param showNodeModules true if the dependency graphs of external modules should be included.
 * @return A list of {parent: String, module: String} which are relative to the original `require`.
 */
function simplifyNames (originalRequest, dependencies, showNodeModules) {
  // This function is a tad complicated because it needs to handle directly requiring a module.
  // For example, `cyclic.require('./server.js')` will get all of a project's dependencies.
  // All that's left is to exclude everything inside of `node_modules` and use relative paths.
  //
  // However, `cyclic.require('mocha')` is also valid. In that case, we need to find `mocha`
  // in a `node_modules` folder somewhere, find its internal dependencies, and discard external dependencies.
  // This is trickier because `mocha` is already inside of a `node_modules` folder.
  // Additionally, some dependencies may be nested in a further `node_modules` folder or as sibling directories.
  const basePath = path.dirname(Module._resolveFilename(originalRequest, module))
  const baseIsModule = isModule(originalRequest)
  let simplifiedDependencies = []
  // Make all paths, even on Windows, use forward slashes.
  for (let dependency of dependencies) {
    let parentPath = path.relative(basePath, dependency.parent).split(path.sep).join('/')
    let modulePath
    if (isModule(dependency.request)) {
      // Use the value passed into `require`.
      modulePath = dependency.request
    } else {
      // Use the path that the `require` got resolved into.
      modulePath = path.relative(basePath, dependency.module).split(path.sep).join('/')
    }

    if (!showNodeModules && looksLikeThirdParty(parentPath, modulePath)) {
      // Skip because this is obviously a node_module and we are supposed to skip those.
      continue
    }

    if (!showNodeModules && baseIsModule && modulePath.startsWith('..')) {
      // Skip because we originally imported an external module (which is in a node_modules) folder.
      // This dependency is in a sibling directory so it is a different module.
      continue
    }
    simplifiedDependencies.push({
      parent: parentPath,
      module: modulePath
    })
  }

  return simplifiedDependencies
}

exports.require = function (entryPoint, showNodeModules) {
  // Fix relative paths so they resolve as if the caller directly `require`d them.
  // Don't touch absolute paths, core modules, and node_modules.
  if (entryPoint.startsWith('.')) {
    entryPoint = path.resolve(getCallerDirectory(), entryPoint)
  }

  let dependencies = []

  let firstRequire = true
  hijackLoad(function visitor (parentPath, modulePath, request) {
    // Skip the first import because that is this file importing the entry point.
    if (firstRequire) {
      firstRequire = false
      return
    }
    dependencies.push({
      parent: parentPath,
      module: modulePath,
      request: request
    })
  })

  return new Promise(function (resolve, reject) {
    process.exit = function () {
      // Something requested that we exit, so return the dependency graph first.
      dependencies = simplifyNames(entryPoint, dependencies, showNodeModules)
      resolve(dependencies)
    }

    let originalCache
    try {
      originalCache = require.cache
      // `require.cache` provides a read-only view into the actual Module cache.
      // Therefore, `require.cache = {}` doesn't do anything.
      // Instead, copy it (see above) and delete all of the keys in it.
      // Restore the copy after we're done.
      for (let key of Object.keys(require.cache)) {
        delete require.cache[key]
      }
      // Add extra places to search so `require` can resolve the path no matter where this actual file is.
      module.paths = Module._nodeModulePaths(process.cwd()).concat(module.paths)
      require(entryPoint)
    } finally {
      // Undo the damage no matter what happens.
      Module._load = originalLoad
      process.exit = originalExit
      require.cache = originalCache
    }

    dependencies = simplifyNames(entryPoint, dependencies, showNodeModules)

    resolve(dependencies)
  })
}
